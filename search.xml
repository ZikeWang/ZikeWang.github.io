<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用vscode配置golang开发环境踩过的坑]]></title>
    <url>%2F2019%2F04%2F14%2F%E4%BD%BF%E7%94%A8vscode%E9%85%8D%E7%BD%AEgolang%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[记录使用vscode进行go开发时，vscode配置上遇到的一些坑及解决方案。 安装tools描述 出现诸如 The &quot;goreturns&quot; command is not available. Use &quot;go get -v github.com/sqs/goreturns&quot; to install. 的提示，可以选择install或者install all。但选择install或者install all后均安装失败：Installing github.com/sqs/goreturns FAILED，应该是国内网络问题。。。方案 创建目录 $GOPATH/src/golang.org/x ，在目录下执行 git clone https://github.com/golang/tools.git tools后，再次出现提示时选择install all即可。除golint继续FAILED外，其余均SUCCEEDED。 安装package描述 problem中提示：cannot find package “golang.org/x/net/…”，除net外，还有text，crypto等。（text添加后会报出很多problems，暂时没有找到解决的方案，未添加）方案 在 $GOROOT/src/golang.org/x 目录下，执行命令 git clone https://github.com/golang/net.git net即可。 参考链接 在VSCode中成功安装Go相关插件问题：tools failed to install. https://blog.csdn.net/dong_beijing/article/details/79653327]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>开发环境</tag>
        <tag>Golang</tag>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置Golang环境]]></title>
    <url>%2F2018%2F05%2F14%2FMac%E4%B8%8B%E9%85%8D%E7%BD%AEGolang%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[本文介绍了在Mac上配置Golang开发环境的大致步骤，包括Go的环境配置和一款IDE——Goland的安装和基本使用方法。 版本OS：macOS High Sierra 10.13.4 Go：1.10.2 darwin/amd64 Goland：2018.1.3 build 181.4892.55 步骤Go的安装使用homebrew以命令行的方式来安装Go：先更新，再安装。 12brew update &amp;&amp; brew upgradebrew install go Go环境变量配置首先创建Go的工作目录，这里在用户目录下建立名为 go_workplace 的目录，并在该目录下分别创建三个子目录：src , bin , pkg 。其中 src 目录主要存放源文件，bin 目录主要存放可执行文件，pkg 目录主要存放包文件。 然后配置 GOPATH 和 GOROOT 两个参数。具体来说，在 .zshrc 中将两个参数分别设置为工作目录的路径和安装路径并设置 PATH 参数，最后使用source命令使配置生效。 123456789cd ~vim .zshrc#insert into .zshrcexport GOROOT=/usr/local/opt/go/libexecexport GOPATH=/Users/kk/go_workplaceexport PATH=$PATH:$GOROOT/bin:$GOPATH/binsource .zshrc 通过命令 go env 可以查看配置后的结果. 安装配置GoLandGoLand是Jetbrains推出的一款Go语言IDE，在官网 Download GoLand for Mac 下载安装即可。 安装后需要配置 GOPATH 和 GOROOT ，在 Configure -&gt; preferences 中添加前面相应的路径即可。 需要注意的一个问题是，Mac下 /usr/local 目录默认对于Finder是隐藏的，这里需要选择 /usr/local 下的子目录，只需在Finder中使用快捷键 command+shift+G，在弹出的会话框中填写需要访问的绝对路径即可。 Hello World在Goland欢迎页面选择 New Project ,然后在 ~/go_workplace/src 下创建项目的目录 Hello_Go 。创建并进入项目后，选择 new -&gt; Go file ，输入源文件名称，选择 simple application 创建，coding，运行即可。 1234567package mainimport "fmt"func main() &#123; fmt.Printf("Hello, world!")&#125; 参考链接Getting started - The Go Programming Language Run GoLand for the first time]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>开发环境</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Vagrant配置CentOS虚拟环境]]></title>
    <url>%2F2018%2F05%2F09%2FMac%E4%B8%8B%E4%BD%BF%E7%94%A8Vagrant%E9%85%8D%E7%BD%AECentOS%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[为了保证开发环境和生产环境的一致性，另外由于有系统洁癖，所以打算在Mac上的一些开发放在虚拟环境中进行。这里以CentOS 7为例来介绍使用Mac+Vagrant+VirtualBox来搭建虚拟环境的方法和过程。 环境OS：macOS High Sierra 10.13.4 Vagrant：2.1.1 VirtualBox：5.2.10 步骤Vagrant和VirtualBox的安装Vagrant下载地址：Download Vagrant for macOS 64bit VirtualBox下载地址：Download VirtualBox for OS X hosts 下载后直接打开安装即可。 PS：安装VirtualBox的过程中可能会遇到安装失败的问题，需要在系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用 中允许安装操作。 CentOS Box的下载使用在线联网的方式安装box往往会因为网络问题而失败，可以在Vagrant Cloud-Discover Vagrant Boxes中先找到并下载好需要的 .box 文件，然后进行本地安装。以CentOS 7为例，currently released version v1803.01的地址是https://app.vagrantup.com/centos/boxes/7/versions/1803.01 ,我们选择provider-virtualbox的版本，则只需在地址栏后追加/providers/virtualbox.box 回车即可下载。 配置开发环境首先配置开发目录，创建目录~/vagrant_project 来存放所有的vagrant项目，并创建子目录~/vagrant_project/CentOS7 作为该Box的工作目录。创建完工作目录后，我们可以将下载好的 .box 文件移动到~/vagrant_project/CentOS7中存放以方便管理。 12345cd ~mkdir vagrant_projectcd vagrant_projectmkdir CentOS7cd CentOS7 接下来我们利用下载好的 .box 文件手动添加box，其格式为 vagrant box add 名称 路径 ，其中名称是管理box所取的名称，路径是 .box 文件所在的路径（这里我将其重命名为了CentOS7180301.box）。 下一步使用 vagrant init 名称 来初始化，名称就是前面我们给box取的名字，初始化后会在目录下生成vagrantfile，这个文件是配置当前box的虚拟机所用的，类似于Docker容器的dockerfile。 接着便可以启动系统，利用命令 vagrant up 来启动虚拟机，第一次启动时可能会花费较长的时间。 启动成功后使用命令 vagrant ssh 连接到虚拟机，类似于远程连接Linux服务器，连接后便可以对虚拟机执行相应的操作。利用 suspend、resume、halt 命令可以对虚拟机分别执行 暂停、恢复、关机 的操作 虚拟机代理设置首先安装相应的vagrant proxy插件，使用命令vagrant plugin install vagrant-proxyconf 进行安装。然后修改配置文件，以Mac上使用代理ss为例，在特定虚拟机的Vagrantfile中，具体来说这里是 ~/vagrant_project/CentOS7/Vagrantfile ，在 Vagrant.configure(&quot;2&quot;) do |config| 后添加： 12345if Vagrant.has_plugin?(&quot;vagrant-proxyconf&quot;) config.proxy.http = &quot;http://proxyserver:port/&quot; config.proxy.https = &quot;http://proxyserver:port/&quot; config.proxy.no_proxy = &quot;localhost,127.0.0.1&quot;end 这里的 proxyserver 和 port 为ss中填写的服务器地址和端口。修改完成后使用命令 vagrant up 启动虚拟机，然后连接到虚拟机并使用命令 curl -v &quot;google.com&quot; 即可检测代理是否成功。 移除开发环境若要移除开发环境，则需分别移除虚拟机和box。 要移除虚拟机，直接删除目录是不行的，需要进入到项目目录，使用命令 vagrant destroy 来删除虚拟机。 最后使用命令 vagrant box remove 来删除添加的box即可。 参考链接 路径（七）：用 Vagrant 管理虚拟机 Vagrant简易教程 Mac上搭建一个干净的TensorFlow环境 Vagrant搭建虚拟化开发环境]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Vagrant</tag>
        <tag>VBox</tag>
        <tag>CentOS</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CRIU实现简单容器的迁移]]></title>
    <url>%2F2018%2F01%2F22%2F%E4%BD%BF%E7%94%A8CRIU%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Docker是一个开源的应用容器引擎，CRIU是一个在 Linux 用户空间 (userspace) 上实现了 checkpoint/restore 功能的开源工具。目前Docker已经支持与CRIU进行整合以管理容器内运行的进程的完整生命周期。本文介绍了利用docker+CRIU实现简单容器应用在主机上的两台虚拟机之间迁移的实验。 实验环境Host：Window 10 pro 64bitVM：Ubuntu 14.04.5-amd64Docker version：17.06.0-ceCRIU version：3.7 实验步骤Docker的安装更新apt包的索引 1sudo apt-get update 安装软件包以允许apt通过HTTPS使用仓库 12345$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 添加Docker的官方GPG密钥 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置仓库为stable 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 再次更新apt包的索引 1sudo apt-get update 查看docker可用的版本 1apt-cache madison docker-ce 这次实验我选择的是17.06.0的版本 1sudo apt-get install docker-ce=17.06.0~ce-0~ubuntu 利用CRIU进行检查点恢复的功能只在docker的实验模式中可用，因此还需使用以下命令开启docker的实验模式 12echo "&#123;\"experimental\": true&#125;" &gt;&gt; /etc/docker/daemon.jsonservice docker restart 到这里，就完成了虚拟机中docker的配置。 CRIU的安装由于CRIU项目已开源，可以到github直接获取其源码，解压后得到文件夹criu-master。获取源码后，在拟机中安装相应的依赖 1sudo apt-get install --no-install-recommends git build-essential libprotobuf-dev libprotobuf-c0-dev protobuf-c-compiler protobuf-compiler python-protobuf libnl-3-dev libpth-dev pkg-config libcap-dev asciidoc xmlto libnet1-dev python-ipaddr iproute2 在文件夹criu-master使用make和make install进行安装。要注意的是 make install 需要在root 权限下执行。 12makemake install 检查CRIU是否安装成功，正常情况下会显示looks good 1criu check 到这里，就完成了CRIU的配置。 ssh的配置本次实验需要将VM1中生成检查点文件传输到VM2中，因此这里还需配置两台虚拟机之间的免密通信。由于两台虚拟机是在同一主机下，所以在VM1上可以直接ping的通VM2。安装ssh相关的服务，安装完成后即可使用scp命令来进行文件传输 1sudo apt-get install ssh openssh-server 在VM1上生成RSA密钥，由于是在root权限下进行的，所以生成的私钥和公钥均保存在目录/root/.ssh下面 1ssh-keygen –t rsa 为了实现免密通信，需要将VM1上生成的公钥保存在VM2，因此需要在VM2中设置.ssh目录并新建文件authorized_keys 123mkdir .sshcd .sshtouch authorized_keys 用scp命令将VM1上的公钥id_rsa.pub拷贝到VM2上，这一步需要输入一次VM2的密码 1scp -p /root/.ssh/id_rsa.pub user@ip_addr:~/.ssh/authorized_keys 到这里，就完成了虚拟机间免密通信的配置。 容器的创建与检查点首先在VM1中 创建并启动 一个简单的容器应用looper，该容器启动后每秒循环加1计数 12docker run -d --name looper --security-opt seccomp:unconfined busybox \ /bin/sh -c 'i=0; while true; do echo $i; i=$(expr $i + 1); sleep 1; done' 创建容器后会返回一个由一大串数字和字母组成的长ID，稍后创建的检查点文件也会生成在以该长ID命名的文件夹下，为了方便后面查找，使用docker的--checkpoint-dir命令来指定检查点文件存放的目录，这里创建了名为checkpoint1的检查点并将文件存放在/tmp目录下 1docker checkpoint create --checkpoint-dir=/tmp looper checkpoint1 通过命令docker logs looper可以看到该容器已停止运行，并且目录/tmp/ID/checkpoints/checkpoint1下生成有checkpoint1的相关检查点文件 容器的迁移与恢复在VM2中 创建 一个相同的容器looper-clone，该容器将利用VM1中容器looper的检查点文件进行启动，并从looper停止的地方继续运行 12docker create --name looper-clone --security-opt seccomp:unconfined busybox \ /bin/sh -c 'i=0; while true; do echo $i; i=$(expr $i + 1); sleep 1; done' 将VM1中生成的检查点文件传输到VM2中，同样为了后面方便使用，把文件存放在VM2的/tmp目录下，这里传输的是文件夹，所以要使用scp -r指令 1scp -r /tmp/ID/checkpoints/checkpoint1 user@ip_addr:/tmp 在VM2中利用checkpoint1的检查点文件启动looper-clone，这里也是使用docker的--checkpoint-dir命令来指定检查点文件存放的目录 1docker start --checkpoint-dir=/tmp --checkpoint=checkpoint1 looper-clone 通过命令docker logs looper-clone可以看到容器从looper停止的地方启动运行并开始计数。 脚本实现半自动迁移手动输入命令行每次测起来比较麻烦，所以分别在两个虚拟机上写了shell脚本来控制迁移的进行。源节点VM1的shell脚本如下 12345#!/bin/bashdocker checkpoint create --checkpoint-dir=/tmp looper checkpoint1results=$(docker inspect -f '&#123;&#123;.Id&#125;&#125;' looper)scp -r /tmp/$results/checkpoints/checkpoint1 kk@192.168.222.136:/tmpecho succeed 目的节点VM2的shell脚本如下 12345678#!/bin/bashwhile($(find /tmp -name checkpoint1))do echo waitingdonedocker create --name looper-clone --security-opt seccomp:unconfined busybox \ /bin/sh -c 'i=0; while true; do echo $i; i=$(expr $i + 1); sleep 1; done'docker start --checkpoint-dir=/tmp --checkpoint=checkpoint1 looper-clone VM2中起初的想法是当VM1的 checkpoint 文件发送到VM2后会产生一个触发的操作，然后VM2中开始执行相应的脚本，但还没想好怎么去解决触发的问题，所以用了一个很笨的循环方法，不断的去查找目录下是否有 checkpoint 文件，如果有的话表示VM2已经接受完成则开始执行后面的脚本。这样的话在启动VM1的脚本时就需要启动VM2的脚本执行循环检测，性能很低，后续还有待改进。 优化方案未完待续。。。 注意问题和一些思考 Docker命令和CRIU需要在root权限下使用 同一台虚拟机Docker的版本和CRIU的 版本 问题。我在进行此实验时遇到过一个问题，就是在一台虚拟机上安装了Docker和CRIU后，对计数容器进行checkpoint操作，这时可以创建检查点并生成检查点文件，但使用docker logs命令发现容器并没有停止运行，那么问题就出在了CRIU上，因为CRIU创建检查点会将进程freeze。起初认为是安装不完整的原因，但重新安装后依然存在这个问题，由于整个迁移是靠Docker与CRIU的整合，于是我开始考虑兼容性的问题。在安装Docker时，最开始是使用命令sudo apt-get install docker-ce，在没有显示指明版本的情况下安装的是docker的最新版本（17.12.0-ce）。CRIU是从github获取的代码也是最新版本（3.7），由于CRIU还很不成熟稳定，我怀疑是Docker的版本太新CRIU还无法很好的兼容，所以尝试降了几个子版本就解决了这个问题。 两台虚拟机CRIU的 版本 问题。由于此次实验是利用VM1上CRIU进行checkpoint操作，利用VM2上的CRIU进行restore操作，因此两台虚拟机上CRIU的版本最好相同或接近。由于我的VM1是之前配置好的（CRIU version=3.2），VM2是新配置的（CRIU version=3.7），导致最初实验在VM2上利用VM1生成的检查点文件进行restore时始终报错criu failed，但在VM2上进行本地checkpoint/restore测试没有任何问题，说明CRIU功能完善，加上碰到过前面2.中的问题，所以很自然的就想到可能是版本不一致，在升级了VM1中的CRIU后实验成功。 相关链接 Get Docker CE for Ubuntu : https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/ Installation-CRIU : https://criu.org/Installation Docker-CRIU : https://criu.org/Docker Github/CRIU : https://github.com/checkpoint-restore/criu]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Docker</tag>
        <tag>CRIU</tag>
        <tag>迁移</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
